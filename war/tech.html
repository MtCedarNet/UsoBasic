<!doctype html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link rel="shortcut icon" href="favicon.ico" />
<title>Some Kind of Nostalism</title>
</head>
<body>

<section>
<h2>概要</h2>
<a href="UsoBasic.jsp">USO 800 BASIC</a>でブラウザ上で動くインタプリタをGWT</a>で作成したので、覚書を残す。
</section>

<section>
<h2>使用ツール</h2>
GWTによりJava用ツールが使用可能のように思われがちである。ただし、
<a href="http://www.gwtproject.org/doc/latest/RefJreEmulation.html">
対応するクラス・メソッド</a>はかなり制限されるため、
何でも使える、というわけではない(しょっちゅう使うメソッドだけある、という感覚）。
インタプリタ作成につき、コンパイラコンパイラが必要となるが、
ここでは、GWTに対応済みである、JavaCCを用いた。<a href="http://www.antlr.org/">ANTLR</a>も同様の用途で
使われるが、依存するライブラリが多く、GWTでは使用できないメソッド・クラスが使われている。
<ol>
<li>Eclipse(3.8)
<li><a href="http://ja.wikipedia.org/wiki/Google_Web_Toolkit">GWT</a>(Java->javascriptコンパイラ)
<li><a href="https://javacc.java.net/">JavaCC/JJtree</a>(java用compiler-compiler)
</ol>
GWTのメリットとして、巷では、「再利用可能で効率的なAjaxソリューション」が強調されるが、個人的には、下記が大きいと思う。
<ol>
<li>Eclipseが使える。on the flyでのsyntax check,自動補完等、非常に強力である。GWT・javaccもeclipseプラグインが用意される
（<a href="https://developers.google.com/eclipse/docs/download">GWTのplugin</a>、
<a href="http://eclipse-javacc.sourceforge.net/">javaccのplugin</a>)ので、通常のjavaプログラムのように編集可能。
<li>Javaの強力な保守性が得られる。javascriptは、どうしても（自分だけ？）gdgdプロになる（ad-hocに
関数のreturn値をHashに変えて、1時間もすれば、何returnしていたか忘れている。変数の型を忘れる、thisが何かわからなくなる、等）。
<li>ブラウザごとのjsの方言をある程度吸収してくれる(1つのプログラムでie8,9,10,gecko,safari別々にjsを作成する)。ただし、
これで互換性考慮不要、というわけではない。
例えば、色指定はプログラム内でユーザが指定するため、rbga(xx,xx,xx,xx)とかするとieで動かなかったり。
</ol>
デメリットは下記通り。
<ol>
<li>開発環境がメモリ食いすぎ。eclipseに加え、localで動作チェックのため、サーバ（jetty）を動かしたうえ、
GWTの開発環境でsuper dev mode(SDM)という、メモリをバカ食いするらしいものを動かす必要あり。
SDM(self destructive modeではないはず)は、GWTの極遅コンパイルを早くするハックらしく、どうも、javaの
インスタンスをメモリに保存し続けているように見える。
</ol>
javaccのメリットは下記通り。
<ol>
<li>依存するライブラリが少ない。パーサ自体は、すべてjavaファイル単体で生成され、jarファイルは使用しない。
<li>jjtreeと一緒に使うと、javaコードを別に記入せずとも各構文定義ごとにインスタンスを生成することができ、AST
(abstract syntax tree、抽象構文木)が自動で生成される。
</ol>
デメリットは下記通り。
<ol>
<li>各構文定義ごとにインスタンスを生成することができる、ということは、
構文定義が多い（≒BASIC命令が多い）と、クラスファイルだらけになるが諦めるしかない。
<li>基本LL(1)、つまり先読みトークンは１つであるが、増やすことができる。しかし、増やした後のconflictのチェックがない。
</ol>

</section>

<section>
<h2>使用フォント</h2>
<a href="https://github.com/yascentur/RictyDiminished">Ricty Diminished</a>を使わさせて頂いている。
非常に綺麗なmonospace fontなので、USO 800 BASICの中身のボロボロを見事にごまかしてくれており、大変ありがとうございます。
あえて言えば、フォント数が少ないので、実は◎とか表示すると、表示が乱れるが内緒である。
<a href="https://github.com/yascentur/Ricty">本家Ricty</a>を使えば良いのいかもしれないが、ライセンスが難しそうなので。
</section>

<section>
<h2>ブラウザ特有の話</h2>
よく言われる話だが、ブラウザはsingle threadであり、ページの再描画含め、イベントを順次実行するモデルである。
そのため、while 1でキー入力待ちでもしようものなら、ページも再描画されず、フリーズ状態となる、いわゆる
「ブラクラ」となる。なので、すべてのBASICの命令の実行は細切れにして、一定のタイミングで次の命令以降の実行を
イベントキューに入れて
（要するにsettimeout/setintervalを実行して)、ブラウザに制御を返す必要がある。

<h3>実装方法</h3>
USO 800 BASICでは、原則実行前に全命令をリストとして実行管理している。
（なので、syntax errorは実行前に出力される）
ただし、ifは例外で、実行時にtrue/falseの判断後、判断に応じた命令を新たにリストに追加して実行している
（一回追加した後、gotoとかで戻ってきたら、使いまわし）。
また、各命令は、1イベント内で実行されるので、短時間で完了することが必要である。なので、
キー入力待が必要なinput系の命令は、一旦実行を停止し、keyイベント内で改行入力後、再度実行を再開している。
input$(数字)実装は、ほぼ断念である。これは、数字の数だけ入力すると文字列が帰ってくる関数である。命令なら停止再開が可能
だが、関数は止めた後、再開することが困難なため、今のところバグ有りを放置し、まともに対応していない。
<br>
さらに忘れてならないのは、single threadでBASIC命令実行、DOM操作（テキスト画面操作後に発生）、ページの再描画を実施しなければならないことである。
ページの再描画はjavscriptで制御できないので再描画したいタイミングで次に実行したかった命令をイベントキューに入れて、
ブラウザが再描画イベントをさっさと入れてくれることを祈るしかない。
結果的に、下記シーケンスとした。
<ol>
<li>1命令実行
<li>下記のいずれかに当てはまれば、次の命令実行を0mS後にsettimeoutする。当てはまらなければ
当てはまるまで連続で次の命令を実行し続ける。
<ol>
<li>命令実行開始から100ｍS経過（ブラクラ防止のため）
<li>DOM操作直後（ページ再描画のため）
</ol>
<li>DOM操作は、非常に重い処理なので、書き換えた部分のみ、かつ100mS間テキスト画面の変更を貯めこんだ後に、settimeoutで
実施している。
</ol>
</section>


<section>
<h2>今後</h2>
バグフィックスや、N88-BASICでの命令関数と互換性のある面白いと思われる拡張は、興味のある限り続けるが、
独自拡張や、PC98ハードウエアのIOにまで手をだすことは考えていない。
信者にしばかれるかもしれないが、独自拡張したところで、いまさらN88-BASICを勉強したり、
新たにプログラムを組む人間がいると思えない。ad-hocにINP/OUT対応したところで
INP/OUTを使っているようなマニアックなプログラムが、動くようになるようにも思えない。
極一般的な、おそらく膨大な既存N88BASICプログラム資産をブラウザ上で再現する、という目標は、現状の仕様で
一応達成できるものと思う（バグがなければ）。
自分で拡張したい方がおられれば、歓迎して、ソースを提供します（コメント１つない汚いソースですが）。

</section>
<section><h2>まとめ</h2>
ブラウザで動くインタプリタの覚書を示した。私はWEB開発なんてド素人の引きこもりニートだが、ツール検討から始めて2ヶ月弱で基本部分ができたので、
いいツール群に恵まれているのだと思う。GWT/JavaCCは日本語の情報が古く、もうオワコンに近いのかもしれないが、
ブラウザアプリとかインタプリタに興味のある方の一助になれば幸いである。
</section>

<section><h2>PS</h2>
N88-BASICは、あまりにもパーサに優しくない言語である。命令の途中でASだとかFとかBFとか、予約語になっていない文字が出てきたり、
どう頑張っても1句先読みですまない命令が多数ある。命令の形式も統一されていないので、
命令すべてパーサで作らなければならない。結局、パーサは現状2500行を超えている。しかもカッコだらけで
よくわからない。
昔の人は、一体どうやって作ったのであろうか。UNIXでクロスコンパイル
環境を作って、yacc(なんてあったのか？)で作ったのであろうか、パーサ自体手で作ったのであろうか？
苦労が忍ばれる。最後に言おう、BASICを選んだのは間違いだった。だれか仕事とお金ください。
</section>
</body>
</html>
