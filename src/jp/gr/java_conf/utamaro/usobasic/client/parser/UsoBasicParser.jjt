options{  JAVA_TEMPLATE_TYPE = "modern";  MULTI = true;  NODE_DEFAULT_VOID = true;  VISITOR = true;  IGNORE_CASE = true;  STATIC = false;  NODE_CLASS = "jp.gr.java_conf.utamaro.usobasic.client.InterpreterNode";  UNICODE_INPUT = true;}PARSER_BEGIN(UsoBasicParser)package jp.gr.java_conf.utamaro.usobasic.client.parser;import java.util.logging.Logger;public class UsoBasicParser{  static private Logger logger = Logger.getLogger("jjt");}PARSER_END(UsoBasicParser)<* >TOKEN :{  < EOF > : DEFAULT}<* >SKIP :{  " "| "\t"| "\n"| "\r"| "'" : Comment}SKIP :{  "rem" : Comment}< Comment >SKIP :{  < ~[ ] >}TOKEN :{  < DOUBLE : ([ "0"-"9" ])* "." ([ "0"-"9" ])    {      8,    }    >| < DOUBLE_EXP : ([ "0"-"9" ])* [ "0"-"9", "." ] ([ "0"-"9" ])* [ "D", "d" ] ([ "-", "+" ])? ([ "0"-"9" ])+ >| < SINGLE : ([ "0"-"9" ])* "." ([ "0"-"9" ])    {      1, 7    }    >| < SINGLE_EXP : ([ "0"-"9" ])* [ "0"-"9", "." ] ([ "0"-"9" ])* "e" ([ "-", "+" ])? ([ "0"-"9" ])+ >| < INTEGER16 : "&h" ([ "0"-"9", "a"-"f" ])+ >| < INTEGER8O : "&o" ([ "0"-"7" ])+ >| < INTEGER8 : "&" ([ "0"-"7" ])+ >| < INTEGER : ([ "0"-"9" ])+ >| < ABS : "abs" >| < AKCNV_D : "akcnv$" >| < AND : "and" >| < ASC : "asc" >| < ATN : "atn" >| < AUTO : "auto" >| < BEEP : "beep" >| < BLOAD : "bload" >| < BSAVE : "bsave" >| < CDBL : "cdbl" >| < CHAIN : "chain" >| < CHR_D : "chr$" >| < CINT : "cint" >| < CIRCLE : "circle" >| < CLEAR : "clear" >| < CLOSE : "close" >| < CLS : "cls" >| < COLOR : "color" >| < COLOR_EQ : "color" ([ "\t", " " ])* "=" >| < COM : "com" >| < COM_ON : "com" ([ "\t", " " ])+ "ON" >| < COM_OFF : "com" ([ "\t", " " ])+ "OFF" >| < COM_STOP : "com" ([ "\t", " " ])+ "STOP" >| < CONSOLE : "console" >| < CONT : "cont" >| < COPY : "copy" >| < COS : "cos" >| < CSNG : "csng" >| < CSRLIN : "csrlin" >| < CVD : "cvd" >| < CVI : "cvi" >| < CVS : "cvs" >| < DATA : "data" > : DATA_STATE| < DATE_D : "date$" >| < DEF : "def" >| < DEF_FN : "def" ([ "\t", " " ])+ "fn" >| < DEFDBL : "defdbl" >| < DEFINT : "defint" >| < DEFSNG : "defsng" >| < DEFSTR : "defstr" >| < DIM : "dim" >| < EDIT : "edit" >| < ELSE : "else" >| < END : "end" >| < EOF_ : "eof" >| < EQV : "eqv" >| < ERASE : "erase" >| < ERL : "erl" >| < ERROR : "error" >| < ERR : "err" >| < EXP : "exp" >| < FIELD : "field" >| < FILES : "files" >| < LFILES : "lfiles" >| < FIX : "fix" >| < FOR : "for" >| < FPOS : "fpos" >| < GET : "get" >| < GET_AT : "get" ([ "\t", " " ])* "@" >| < GOSUB : "gosub" >| < GOTO : "go" ([ "\t", " " ])* "to" >| < HELP : "help" >| < HELP_ON : "help" ([ "\t", " " ])+ "on" >| < HELP_OFF : "help" ([ "\t", " " ])+ "off" >| < HELP_STOP : "help" ([ "\t", " " ])+ "stop" >| < HEX_D : "hex$" >| < IF : "if" >| < IMP : "imp" >| < INKEY_D : "inkey$" >| < INPUT : "input" >| < INPUT_SHARP : "input" ([ "\t", " " ])* "#" >| < INPUT_D : "input$" >| < INSTR : "instr" >| < INT : "int" >| < INP : "inp" >| < JIS_D : "jis$" >| < KACNV_D : "kacnv$" >| < KANJI : "kanji" >| < KEY : "key" >| < KEY_LIST : "key" ([ "\t", " " ])+ "list" >| < KILL : "kill" >| < KINSTR : "kinstr" >| < KLEN : "klen" >| < KMID_D : "kmid$" >| < KNJ_D : "knj$" >| < LEFT_D : "left$" >| < LEN : "len" >| < LET : "let" >| < LINE : "line" >| < LINE_INPUT : "line" ([ "\t", " " ])+ "input" >| < LINE_INPUT_SHARP : "line" ([ "\t", " " ])+ "input" ([ "\t", " " ])* "#" >| < LIST : "list" >| < LLIST : "llist" >| < LOAD : "load" >| < LOCATE : "locate" >| < LOC : "loc" >| < LOF : "lof" >| < LOG : "log" >| < LPRINT : "lprint" >| < LPRINT_USING : "lprint" ([ "\t", " " ])+ "using" >| < LSET : "lset" >| < MID_D : "mid$" >| < MKD_D : "mkd$" >| < MKI_D : "mki$" >| < MKS_D : "mks$" >| < MOD : "mod" >| < MOUSE : "mouse" >| < MOUSE_ON : "mouse" ([ "\t", " " ])+ "on" >| < MOUSE_OFF : "mouse" ([ "\t", " " ])+ "off" >| < MOUSE_STOP : "mouse" ([ "\t", " " ])+ "stop" >| < NAME : "name" >| < NEXT : "next" >| < NEW : "new" >| < NOT : "not" >| < OCT_D : "oct$" >| < OFF : "off" >| < ON : "on" >| < ON_COM_GOSUB : "on" ([ "\t", " " ])+ "com" ([ "\t", " " ])+ "gosub" >| < ON_ERROR_GOTO : "on" ([ "\t", " " ])+ "error" ([ "\t", " " ])+ "goto" >| < ON_HELP_GOSUB : "on" ([ "\t", " " ])+ "help" ([ "\t", " " ])+ "gosub" >| < ON_KEY_GOSUB : "on" ([ "\t", " " ])+ "key" ([ "\t", " " ])+ "gosub" >| < ON_MOUSE_GOSUB : "on" ([ "\t", " " ])+ "mouse" ([ "\t", " " ])+ "gosub" >| < ON_PEN_GOSUB : "on" ([ "\t", " " ])+ "pen" ([ "\t", " " ])+ "gosub" >| < ON_STOP_GOSUB : "on" ([ "\t", " " ])+ "stop" ([ "\t", " " ])+ "gosub" >| < OPEN : "open" >| < OR : "or" >| < PAINT : "paint" >| < PEN : "pen" >| < PEN_ON : "pen" ([ "\t", " " ])+ "on" >| < PEN_OFF : "pen" ([ "\t", " " ])+ "off" >| < PEN_STOP : "pen" ([ "\t", " " ])+ "stop" >| < POINT : "point" >| < POS : "pos" >| < PRESET : "preset" >| < PRINT : "print" >| < PRINT_SHARP : "print" ([ "\t", " " ])* "#" >| < PRINT_USING : "print" ([ "\t", " " ])+ "USING" >| < PSET : "pset" >| < PUT : "put" >| < PUT_AT : "put" ([ "\t", " " ])* "@" >| < RANDOMIZE : "randomize" >| < READ : "read" >| < RENUM : "renum" >| < RESTORE : "restore" >| < RESUME_NEXT : "resume" ([ "\t", " " ])+ "next" >| < RESUME : "resume" >| < RETURN : "return" >| < RIGHT_D : "right$" >| < RND : "rnd" >| < ROLL : "roll" >| < RSET : "rset" >| < RUN : "run" >| < SAVE : "save" >| < SCREEN : "screen" >| < SEARCH : "search" >| < SGN : "sgn" >| < SIN : "sin" >| < SPACE_D : "space$" >| < SPC : "spc" >| < SQR : "sqr" >| < STEP : "step" >| < STOP : "stop" >| < STOP_ON : "stop" ([ "\t", " " ])+ "on" >| < STOP_OFF : "stop" ([ "\t", " " ])+ "off" >| < STOP_STOP : "stop" ([ "\t", " " ])+ "stop" >| < STR_D : "str$" >| < STRING_D : "string$" >| < SWAP : "swap" >| < TAB : "tab" >| < TAN : "tan" >| < THEN : "then" >| < TIME_D : "time$" >| < TRON : "tron" >| < TROFF : "troff" >| < TO : "to" >| < USING : "using" >| < VAL : "val" >| < WEND : "wend" >| < WHILE : "while" >| < WIDTH : "width" >| < WRITE : "write" >| < WRITE_SHARP : "write" ([ "\t", " " ])+ "#" >| < XOR : "xor" >| < STRING : "\"" (~[ "\"" ])* "\"" >| < AS : "as" >| < GO : "go" >| < ALL : "all" >| < B : "b" >| < R : "r" >| < F : "f" >| < Y : "y" >| < A : "a" >| < P : "p" >| < N : "n" >| < BF : "bf" >| < BASE : "base" >| < OUTPUT : "output" >| < APPEND : "append" >| < ALPHABET : [ "a"-"z" ] >| < IDENTIFIER : [ "a"-"z" ] ([ "0"-"9", "a"-"z", "." ])* ([ "$", "#", "!", "%" ])? >| < SEMICOLON : ";" >| < COMMA : "," >| < COLON : ":" >| < EXCLAMATION : "!" >| < HASH : "#" >| < PERCENT : "%" >| < LPAREN : "(" >| < RPAREN : ")" >| < ASTER : "*" >| < PLUS : "+" >| < MINUS : "-" >| < DOT : "\\." >| < SLASH : "/" >| < BIGGER : "<" >| < EQUAL : "=" >| < LESS : ">" >| < QUESTION : "?" >| < BACK_SLASH : "\\" >| < CARET : "^" >}< DATA_STATE >TOKEN :{  < DATA_STRING : "\"" (~[ "\"" ])+ "\"" >| < DATA_ANY : (~[ "\t", " ", ",", "'", ":" ])+ >| < DATA_COMMA : "," >| < DATA_COLON : ":" > : DEFAULT}<* >TOKEN :{  < MISC : ~[ ] >}Token alphabet() #alphabet :{  Token t;}{  (    t = < ALPHABET >  | t = < B >  | t = < R >  | t = < F >  | t = < Y >  | t = < A >  | t = < P >  | t = < N >  )  {    return t;  }}Token identifier() #identifier :{  Token t;}{  (    t = < AS >  | t = < GO >  | t = < ALL >  | t = < B >  | t = < R >  | t = < F >  | t = < Y >  | t = < A >  | t = < P >  | t = < N >  | t = < BF >  | t = < BASE >  | t = < ALPHABET >  | t = < OUTPUT >  | t = < APPEND >  | t = < IDENTIFIER >  )  {    jjtThis.addToken(t);    return t;  }}Token label() #label :{  Token t;}{  "*" t = identifier()  {    jjtThis.addToken(t);    return t;  }}ASTstatements statements() #statements :{}{  (    label()  | statement()  )  (    (      < COLON >    | < DATA_COLON >    )    statement()  )*  < EOF >  {    return jjtThis;  }}void statement() #statement :{}{  stateAUTO()| stateBEEP()| stateBLOAD()| stateBSAVE()| stateCHAIN()| stateCIRCLE()| stateCLEAR()| stateCLOSE()| stateCLS()| stateCOLOR()| stateCOLOR_EQ()| stateCOM_ONOFF()| stateCONSOLE()| stateCONT()| stateCOPY()| stateDATA()| stateDEFFN()| stateDEFINT()| stateDEFSNG()| stateDEFDBL()| stateDEFSTR()| stateDIM()| stateEDIT()| stateEND()| stateERASE()| stateERROR()| stateFIELD()| stateFILES()| stateLFILES()| stateFOR()| stateGET()| stateGET_AT()| stateGOSUB()| stateGOTO()| stateHELP_ONOFF()| stateIF()| stateINPUT()| stateINPUT_S()| LOOKAHEAD(< KEY > expressionNoEmpty() ",")  stateKEY()| stateKEYLIST()| stateKEY_ONOFF()| stateKILL()| stateLET()| stateLINE()| stateLINEINPUT()| stateLINEINPUT_S()| stateLIST()| stateLLIST()| stateLOAD()| stateLOCATE()| stateLPRINT()| stateLPRINTUSING()| stateLSET()| stateMID()| stateMOUSE_ONOFF()| stateNAME()| stateNEW()| stateNEXT()| stateONERROR()| stateONCOM()| stateONGO()| stateONHELP()| stateONKEY()| stateONMOUSE()| stateONPEN()| stateONSTOP()| stateOPEN()| statePAINT()| statePEN_ONOFF()| statePOINT()| statePRESET()| statePRINT()| statePRINT_S()| statePRINTUSING()| statePSET()| statePUT_AT()| statePUT()| stateRANDMIZE()| stateREAD()| stateRENUM()| stateRESTORE()| stateRESUME()| stateRESUMENEXT()| stateRETURN()| stateROLL()| stateRSET()| stateRUN()| stateSAVE()| stateSCREEN()| stateSTOP()| stateSTOP_ONOFF()| stateSWAP()| stateTRON()| stateTROFF()| stateWHILE()| stateWEND()| stateWIDTH()| stateWRITE()| stateWRITE_S()|  {}}void stateAUTO() #stateAUTO :{}{  < AUTO > expression()  (    "," expression()  )?}void stateBEEP() #stateBEEP :{}{  < BEEP > expression()}void stateBLOAD() #stateBLOAD :{}{  < BLOAD > expression() "," identifier()}void stateBSAVE() #stateBSAVE :{}{  < BSAVE > expression() "," identifier()}void stateCHAIN() #stateCHAIN :{}{  < CHAIN > expression()  (    "," expression()  )?  (    all()  )?}void stateCIRCLE() #stateCIRCLE :{  Token t = null;}{  < CIRCLE > point() "," expression()  (    "," expression()    (      "," expression()      (        "," expression()        (          "," expression()          (            "," t = f()            (              "," expression()            )?          )?        )?      )?    )?  )?  {    jjtThis.addToken(t);  }}void stateCLEAR() #stateCLEAR :{}{  < CLEAR > expression() expression_3()}void stateCLOSE() #stateCLOSE :{}{  < CLOSE > ("#")? expression()  (    "," ("#")? expression()  )*}void stateCLS() #stateCLS :{}{  < CLS > expression()}void stateCOLOR() #stateCOLOR :{}{  < COLOR > expression() expression_4()}void stateCOLOR_EQ() #stateCOLOR_EQ :{}{  < COLOR_EQ > point()}void stateCOM_ONOFF() #stateCOM_ONOFF :{  Token t;}{  (    t = < COM_ON >  | t = < COM_OFF >  | t = < COM_STOP >  )  {    jjtThis.addToken(t);  }}void stateCONSOLE() #stateCONSOLE :{}{  < CONSOLE > expression() expression_4()}void stateCONT() #stateCONT :{}{  < CONT >}void stateCOPY() #stateCOPY :{}{  < COPY > expression()}Token datas() #datas :{  Token t;}{  (    t = < DATA_ANY >  | t = < DATA_STRING >  )  {    jjtThis.addToken(t);    return t;  }}ASTstateDATA stateDATA() #stateDATA :{  Token t;}{  < DATA > t = datas()  {    jjtThis.addToken(t);  }  (    < DATA_COMMA > t = datas()    {      jjtThis.addToken(t);    }  )*  {    return jjtThis;  }}void stateDEFFN() #stateDEFFN :{  Token t = null;}{  < DEF_FN > t = identifier()  {    jjtThis.addToken(t);  }  (    "(" t = identifier()    {      jjtThis.addToken(t);    }    (      "," t = identifier()      {        jjtThis.addToken(t);      }    )*    ")"  )?  "=" expression()}void stateDEFINT() #stateDEFINT :{}{  < DEFINT > alphabetRange()  (    "," alphabetRange()  )*}void stateDEFSNG() #stateDEFSNG :{}{  < DEFSNG > alphabetRange()  (    "," alphabetRange()  )*}void stateDEFDBL() #stateDEFDBL :{}{  < DEFDBL > alphabetRange()  (    "," alphabetRange()  )*}void stateDEFSTR() #stateDEFSTR :{}{  < DEFSTR > alphabetRange()  (    "," alphabetRange()  )*}void stateDIM() #stateDIM :{}{  < DIM > array()  (    "," array()  )*}void stateEDIT() #stateEDIT :{}{  < EDIT >  (    lineNumber()  )?}void stateEND() #stateEND :{}{  < END >}void stateERASE() #stateERASE :{}{  < ERASE > identifier()  (    "," identifier()  )*}void stateERROR() #stateERROR :{}{  < ERROR > expression()}void stateFIELD() #stateFIELD :{}{  < FIELD > ("#")? expression() "," expression() < AS > variable()  (    "," expression() < AS > variable()  )*}void stateFILES() #stateFILES :{}{  < FILES > expression()}void stateLFILES() #stateLFILES :{}{  < LFILES > expression()}void stateFOR() #stateFOR :{}{  < FOR > variable() "=" expressionNoEmpty() < TO > expressionNoEmpty()  (    < STEP > expressionNoEmpty()  )?}void stateNEXT() #stateNEXT :{}{  < NEXT >  (    variables()  )?}void stateGET() #stateGET :{}{  < GET > ("#")? expression()  (    "," expression()  )?}void stateGET_AT() #stateGET_AT :{}{  < GET_AT > pointRange() "," variable()}void stateGOSUB() #stateGOSUB :{}{  < GOSUB > lineNumber()}void stateGOTO() #stateGOTO :{}{  < GOTO > lineNumber()}void stateHELP_ONOFF() #stateHELP_ONOFF :{  Token t;}{  (    t = < HELP_ON >  | t = < HELP_OFF >  | t = < HELP_STOP >  )  {    jjtThis.addToken(t);  }}void stateIF() #stateIF :{}{  (    < IF > expression()    (      (        (          (            < THEN >            (              lineNumber()            | statement()            )          )        |          (            < GOTO > lineNumber()          )        )        (          ":" statement()        )*      ) #stateIfTrue)    (      < ELSE >      (        (          lineNumber()        | statement()        )        (          ":" statement()        )*      )    )?    #stateIfFalse < EOF >)}void stateINPUT() #stateINPUT :{  Token t = null;}{  < INPUT >  (    t = < STRING > colon()  )?  {    jjtThis.addToken(t);  }  variables()}void stateINPUT_S() #stateINPUT_S :{}{  < INPUT_SHARP > expression() "," variables()}void stateKEY() #stateKEY :{}{  < KEY > expressionNoEmpty() "," expressionNoEmpty()}void stateKEYLIST() #stateKEYLIST :{}{  < KEY_LIST >}void stateKEY_ONOFF() #stateKEY_ONOFF :{  Token t;}{  (    < KEY >    (      "(" expressionNoEmpty() ")"    )?    (      t = < ON >    | t = < OFF >    | t = < STOP >    )  )  {    jjtThis.addToken(t);  }}void stateKILL() #stateKILL :{}{  < KILL > expression()}void stateLET() #stateLET :{}{  (< LET >)? variable() "=" expression()}void stateLINE() #stateLINE :{}{  < LINE >  (    point()  )?  #point1 "-" point()(  "," expression()  (    "," bf()    (      "," expression()    )?  )?)?}void stateLINEINPUT() #stateLINEINPUT :{  Token t = null;}{  < LINE_INPUT >  (    t = < STRING > colon()  )?  {    jjtThis.addToken(t);  }  variable()}void stateLINEINPUT_S() #stateLINEINPUT_S :{}{  < LINE_INPUT_SHARP > expression() "," variable()}void stateLIST() #stateLIST :{}{  < LIST >  (    lineNumberRange()  )?}void stateLLIST() #stateLLIST :{}{  < LLIST >  (    lineNumberRange()  )?}void stateLOAD() #stateLOAD :{}{  < LOAD > expression()  (    "," r()  )?}void stateLOCATE() #stateLOCATE :{}{  < LOCATE > expression() expression_2()}void stateLSET() #stateLSET :{}{  < LSET > variable() "=" expression()}void stateRSET() #stateRSET :{}{  < RSET > variable() "=" expression()}void stateMID() #stateMID :{}{  < MID_D > "(" variable() "," expression()  (    "," expression()  )?  ")" "=" expression()}void stateNAME() #stateNAME :{}{  < NAME > expression() < AS > expression()}void stateNEW() #stateNEW :{}{  < NEW >}void stateONCOM() #stateONCOM :{}{  < ON_COM_GOSUB > lineNumber()}void stateONERROR() #stateONERROR :{}{  < ON_ERROR_GOTO > lineNumber()}void stateONGO() #stateONGO :{  Token t;}{  (    < ON > expression()    (      t = < GOTO >    | t = < GOSUB >    )    lineNumber()    (      "," lineNumber()    )*  )  {    jjtThis.addToken(t);  }}void stateONHELP() #stateONHELP :{}{  < ON_HELP_GOSUB > lineNumber()}Token lineNumberWithEmpty() #lineNumber :{  Token t = null;}{  (    t = < INTEGER >  | t = label()  |    {}  )  {    jjtThis.addToken(t);    return t;  }}void stateONKEY() #stateONKEY :{}{  < ON_KEY_GOSUB > lineNumberWithEmpty()  (    "," lineNumberWithEmpty()  )*}void stateONMOUSE() #stateONMOUSE :{}{  < ON_MOUSE_GOSUB > lineNumber()}void stateONPEN() #stateONPEN :{}{  < ON_PEN_GOSUB > lineNumber()}void stateONSTOP() #stateONSTOP :{}{  < ON_STOP_GOSUB > lineNumber()}void stateOPEN() #stateOPEN :{}{  < OPEN > expression()  (    < FOR > fileMode()  )?  < AS > ("#")? expression()}void statePAINT() #statePAINT :{}{  < PAINT > point()  (    "," expression()    (      "," expression()    )?  )?}void statePEN_ONOFF() #statePEN_ONOFF :{  Token t;}{  (    t = < PEN_ON >  | t = < PEN_OFF >  | t = < PEN_STOP >  )  {    jjtThis.addToken(t);  }}void statePOINT() #statePOINT :{}{  < POINT > point()}void statePRESET() #statePRESET :{}{  < PRESET > point()  (    "," expression()  )?}void statePRINT() #statePRINT :{}{  (    "?"  | < PRINT >  )  (    spc()  | tab()  | expression()  )  (    colon()    (      spc()    | tab()    | expression()    )  )*}void stateLPRINT() #stateLPRINT :{}{  (< LPRINT >) expression()  (    colon()    (      spc()    | tab()    | expression()    )  )*}void stateMOUSE_ONOFF() #stateMOUSE_ONOFF :{  Token t;}{  (    t = < MOUSE_ON >  | t = < MOUSE_OFF >  | t = < MOUSE_STOP >  )  {    jjtThis.addToken(t);  }}void statePRINT_S() #statePRINT_S :{  Token t = null;}{  < PRINT_SHARP > expressionNoEmpty() ","  (    (      t = < USING > expressionNoEmpty() ";" expressionNoEmpty()    )    {      jjtThis.addToken(t);    }  | expression()  )  (    colon() expression()  )*}void stateLPRINTUSING() #stateLPRINTUSING :{}{  < LPRINT_USING > expression() ";" expression()  (    colon() expression()  )*}void statePRINTUSING() #statePRINTUSING :{}{  < PRINT_USING > expression() ";" expression()  (    colon() expression()  )*}void statePSET() #statePSET :{}{  < PSET > point()  (    "," expression()  )?}void statePUT() #statePUT :{}{  < PUT > ("#")? expression()  (    "," expression()  )?}void statePUT_AT() #statePUT_AT :{  Token t = null;}{  < PUT_AT > point() ","  (    (      variable()    )  |    (      t = < KANJI > "(" expression() ")"    )    {      jjtThis.addToken(t);    }  )  (    LOOKAHEAD(2)    "," getCondition()  )?  (    "," expression() "," expression()  )?}void stateRANDMIZE() #stateRANDOMIZE :{}{  < RANDOMIZE > expression()}void stateREAD() #stateREAD :{}{  < READ > variables()}void stateRENUM() #stateRENUM :{  Token t = null;}{  < RENUM >  (    expression() #renumNew)  (    ","    (      expression() #renumOld)    (      "," expression() #renumStep)?  )?}void stateRESTORE() #stateRESTORE :{}{  < RESTORE >  (    lineNumber()  )?}void stateRESUME() #stateRESUME :{}{  < RESUME > lineNumber()}void stateRESUMENEXT() #stateRESUMENEXT :{}{  < RESUME_NEXT >}void stateRETURN() #stateRETURN :{}{  < RETURN >  (    lineNumber()  )?}void stateROLL() #stateROLL :{  Token t = null;}{  < ROLL > expression()  (    "," expression()    (      "," t = ny()      {        jjtThis.addToken(t);      }    )?  )?}void stateRUN() #stateRUN :{  Token t = null;}{  < RUN >  (    lineNumber()  |    (      t = < STRING >      (        "," r()      )?    )    {      jjtThis.addToken(t);    }  |    {}  )}void spc() #spc :{}{  < SPC > "(" expressionNoEmpty() ")"}void stateSAVE() #stateSAVE :{}{  < SAVE > expression()  (    ap()  )?}void stateSCREEN() #stateSCREEN :{}{  < SCREEN > expression() expression_3()}void stateSTOP() #stateSTOP :{}{  < STOP >}void stateSTOP_ONOFF() #stateSTOP_ONOFF :{  Token t;}{  (    t = < STOP_ON >  | t = < STOP_OFF >  | t = < STOP_STOP >  )  {    jjtThis.addToken(t);  }}void stateSWAP() #stateSWAP :{}{  < SWAP > variable() "," variable()}void tab() #tab :{}{  < TAB > "(" expressionNoEmpty() ")"}void stateTRON() #stateTRON :{}{  < TRON >}void stateTROFF() #stateTROFF :{}{  < TROFF >}void stateWHILE() #stateWHILE :{}{  < WHILE > expression()}void stateWEND() #stateWEND :{}{  < WEND >}void stateWIDTH() #stateWIDTH :{}{  < WIDTH > expression()  (    "," expression()  )?}void stateWRITE() #stateWRITE :{}{  < WRITE > expression()  (    colon() expression()  )*}void stateWRITE_S() #stateWRITE_S :{}{  < WRITE_SHARP > expression() "," expression()  (    colon() expression()  )*}Token bf() #token :{  Token t = null;}{  (    t = < B >  | t = < BF >  |    {}  )  {    jjtThis.addToken(t);    return t;  }}Token pr() #token :{  Token t;}{  (    t = < P >  | t = < R >  )  {    jjtThis.addToken(t);    return t;  }}Token ny() #token :{  Token t;}{  (    t = < N >  | t = < Y >  )  {    jjtThis.addToken(t);    return t;  }}Token ap() #token :{  Token t;}{  (    t = < A >  | t = < P >  )  {    jjtThis.addToken(t);    return t;  }}Token r() #token :{  Token t;}{  (t = < R >)  {    jjtThis.addToken(t);    return t;  }}Token all() #token :{  Token t;}{  t = < ALL >  {    jjtThis.addToken(t);    return t;  }}Token f() #token :{  Token t;}{  (t = < F >)  {    jjtThis.addToken(t);    return t;  }}Token bbf() #token :{  Token t;}{  (    t = < B >  | t = < BF >  )  {    jjtThis.addToken(t);    return t;  }}Token getCondition() #token :{  Token t;}{  (    t = < PSET >  | t = < PRESET >  | t = < OR >  | t = < AND >  | t = < XOR >  )  {    jjtThis.addToken(t);    return t;  }}Token fileMode() #token :{  Token t;}{  (    t = < INPUT >  | t = < OUTPUT >  | t = < APPEND >  )  {    jjtThis.addToken(t);    return t;  }}Token colon() #token :{  Token t;}{  (    t = ";"  | t = ","  )  {    jjtThis.addToken(t);    return t;  }}void variable() #variable :{  Token t = null;}{  (    t = identifier()    (      "(" expressionNoEmpty()      (        "," expressionNoEmpty()      )*      ")"    )?  )  {    jjtThis.addToken(t);  }}void point() :{}{  "(" expression() "," expression() ")"}Token pointRange() #pointRange :{  Token t = null;}{  point() "-"  (    point()  | t = < STEP > point()  )  {    jjtThis.addToken(t);    return t;  }}void variables() #variables :{}{  variable()  (    "," variable()  )*}void array() #array :{  Token t;}{  t = identifier() "(" expression()  (    "," expression()  )*  ")"  {    jjtThis.addToken(t);  }}void lineNumberRange() #lineNumberRange :{  Token t = null;}{  (    (      (        lineNumber()        (          t = "-"          {            jjtThis.addToken(t);          }          (            lineNumber()          )?        )?      ) #lineNumberFrom)  |    (      "-" lineNumber() #lineNumberTo)  )}void alphabetRange() #alphabetRange :{  Token [ ] t = new Token [ 2 ];}{  (    t [ 0 ] = alphabet()    (      "-" t [ 1 ] = alphabet()    )?  )  {    jjtThis.addToken(t);  }}void expression_2() :{}{  (    "," expression()    (      "," expression()    )?  )?}void expression_3() :{}{  (    "," expression()    (      "," expression()      (        "," expression()      )?    )?  )?}void expression_4() :{}{  (    "," expression()    (      "," expression()      (        "," expression()        (          "," expression()        )?      )?    )?  )?}Token integer() #integer :{  Token t;}{  t = < INTEGER >  {    jjtThis.addToken(t);    return t;  }}Token lineNumber() #lineNumber :{  Token t;}{  (    t = < INTEGER >  | t = label()  )  {    jjtThis.addToken(t);    return t;  }}void expression() #expression :{}{  eqvExpression()| empty()}void expressionNoEmpty() #expression :{}{  eqvExpression()}void eqvExpression() :{}{  impExpression()  (    < EQV > impExpression() #opEQV(2))*}void impExpression() :{}{  xorExpression()  (    < IMP > xorExpression() #opIMP(2))*}void xorExpression() :{}{  orExpression()  (    < XOR > orExpression() #opXOR(2))*}void orExpression() :{}{  andExpression()  (    < OR > andExpression() #opOR(2))*}void andExpression() :{}{  notExpression()  (    < AND > notExpression() #opAND(2))*}void notExpression() :{}{  equalityExpression()| < NOT > notExpression() #opNOT(1)}void equalityExpression() :{}{  additiveExpression()  (    LOOKAHEAD(2)    "=" additiveExpression() #opEQL(2)| LOOKAHEAD(2)  "<" ">" additiveExpression() #opNEQ(2)| LOOKAHEAD(2)">" "<" additiveExpression() #opNEQ(2)| LOOKAHEAD(2)"<" additiveExpression() #opLT(2)| LOOKAHEAD(2)">" additiveExpression() #opGT(2)| "<" "=" additiveExpression() #opLE(2)| LOOKAHEAD(2)"=" "<" additiveExpression() #opLE(2)| ">" "=" additiveExpression() #opGE(2)| "=" ">" additiveExpression() #opGE(2))?}/** Additive expression. */void additiveExpression() :{}{  modExpression()  (    "+" modExpression() #opADD(2)| "-" modExpression() #opMINUS(2))*}void modExpression() :{}{  integer_multiplicativeExpression()  (    < MOD > integer_multiplicativeExpression() #opMOD(2))*}/** Multiplicative expression. */void integer_multiplicativeExpression() :{}{  multiplicativeExpression()  (    "\\" multiplicativeExpression() #opIDIV(2))*}void multiplicativeExpression() :{}{  unaryExpression()  (    LOOKAHEAD(1)    (      "/" unaryExpression() #opDIV(2)  | "*" unaryExpression() #opMUL(2)))*}/** Unary expression. */void unaryExpression() :{}{  expExpression()| "-" expExpression() #opNEG(1)| "+" expExpression() #opPOS(1)}void expExpression() :{}{  functionExpression()  (    "^" functionExpression() #opPOW(2))*}void functionExpression() :{}{  primaryExpression()| funcABS()| funcAKCNV()| funcASC()| funcATN()| funcCDBL()| funcCHR()| funcCINT()| funcCOS()| funcCSNG()| funcCSRLIN()| funcCVI()| funcCVS()| funcCVD()| funcDATE()| funcEOF()| funcERL()| funcERR()| funcEXP()| funcFIX()| funcFPOS()| funcHEX()| funcINKEY()| funcINP()| funcINPUT()| funcINSTR()| funcINT()| funcJIS()| funcKACNV()| funcKINSTR()| funcKLEN()| funcKMID()| funcKNJ()| funcLEFT()| funcLEN()| funcLOC()| funcLOF()| funcLOG()| funcMID()| funcMKI()| funcMKS()| funcMKD()| funcMOUSE()| funcOCT()| funcPEN()| funcPOINT()| funcPOS()| funcRIGHT()| funcRND()| funcSEARCH()| funcSGN()| funcSIN()| funcSPACE()| funcSQR()| funcSTR()| funcSTRING()| funcTAN()| funcTIME()| funcVAL()}void funcABS() #funcABS :{}{  < ABS > "(" expressionNoEmpty() ")"}void funcAKCNV() #funcAKCNV :{}{  < AKCNV_D > "(" expressionNoEmpty() ")"}void funcASC() #funcASC :{}{  < ASC > "(" expressionNoEmpty() ")"}void funcATN() #funcATN :{}{  < ATN > "(" expressionNoEmpty() ")"}void funcCDBL() #funcCDBL :{}{  < CDBL > "(" expressionNoEmpty() ")"}void funcCHR() #funcCHR :{}{  < CHR_D > "(" expressionNoEmpty() ")"}void funcCINT() #funcCINT :{}{  < CINT > "(" expressionNoEmpty() ")"}void funcCOS() #funcCOS :{}{  < COS > "(" expressionNoEmpty() ")"}void funcCSNG() #funcCSNG :{}{  < CSNG > "(" expressionNoEmpty() ")"}void funcCSRLIN() #funcCSRLIN :{}{  < CSRLIN >}void funcCVI() #funcCVI :{}{  < CVI > "(" expressionNoEmpty() ")"}void funcCVS() #funcCVS :{}{  < CVS > "(" expressionNoEmpty() ")"}void funcCVD() #funcCVD :{}{  < CVD > "(" expressionNoEmpty() ")"}void funcDATE() #funcDATE :{}{  < DATE_D >}void funcEOF() #funcEOF :{}{  < EOF_ > "(" expressionNoEmpty() ")"}void funcERL() #funcERL :{}{  < ERL >}void funcERR() #funcERR :{}{  < ERR >}void funcEXP() #funcEXP :{}{  < EXP > "(" expressionNoEmpty() ")"}void funcFIX() #funcFIX :{}{  < FIX > "(" expressionNoEmpty() ")"}void funcFPOS() #funcFPOS :{}{  < FPOS > "(" expressionNoEmpty() ")"}void funcHEX() #funcHEX :{}{  < HEX_D > "(" expressionNoEmpty() ")"}void funcINKEY() #funcINKEY :{}{  < INKEY_D >}void funcINP() #funcINP :{}{  < INP > "(" expressionNoEmpty() ")"}void funcINPUT() #funcINPUT :{}{  < INPUT_D > "(" expressionNoEmpty()  (    "," ("#")? expressionNoEmpty()  )?  ")"}void funcINSTR() #funcINSTR :{}{  < INSTR > "(" expressionNoEmpty() "," expressionNoEmpty()  (    "," expressionNoEmpty()  )?  ")"}void funcINT() #funcINT :{}{  < INT > "(" expressionNoEmpty() ")"}void funcJIS() #funcJIS :{}{  < JIS_D > "(" expressionNoEmpty() ")"}void funcKACNV() #funcKACNV :{}{  < KACNV_D > "(" expressionNoEmpty() ")"}void funcKINSTR() #funcINSTR :{}{  < KINSTR > "(" expressionNoEmpty() "," expressionNoEmpty()  (    "," expressionNoEmpty()  )?  ")"}void funcKLEN() #funcKLEN :{}{  < KLEN > "(" expressionNoEmpty()  (    "," expressionNoEmpty()  )?  ")"}void funcKMID() #funcKMID :{}{  < KMID_D > "(" expressionNoEmpty() "," expressionNoEmpty()  (    "," expressionNoEmpty()  )?  ")"}void funcKNJ() #funcKNJ :{}{  < KNJ_D > "(" expressionNoEmpty() ")"}void funcLEFT() #funcLEFT :{}{  < LEFT_D > "(" expressionNoEmpty() "," expressionNoEmpty() ")"}void funcLEN() #funcLEN :{}{  < LEN > "(" expressionNoEmpty() ")"}void funcLOC() #funcLOC :{}{  < LOC > "(" expressionNoEmpty() ")"}void funcLOF() #funcLOF :{}{  < LOF > "(" expressionNoEmpty() ")"}void funcLOG() #funcLOG :{}{  < LOG > "(" expressionNoEmpty() ")"}void funcMID() #funcMID :{}{  < MID_D > "(" expressionNoEmpty() "," expressionNoEmpty()  (    "," expressionNoEmpty()  )?  ")"}void funcMKI() #funcMKI :{}{  < MKI_D > "(" expressionNoEmpty() ")"}void funcMKS() #funcMKS :{}{  < MKS_D > "(" expressionNoEmpty() ")"}void funcMKD() #funcMKD :{}{  < MKD_D > "(" expressionNoEmpty() ")"}void funcMOUSE() #funcMOUSE :{}{  < MOUSE > "(" expressionNoEmpty()  (    "," expressionNoEmpty()  )?  ")"}void funcOCT() #funcOCT :{}{  < OCT_D > "(" expressionNoEmpty() ")"}void funcPEN() #funcPEN :{}{  < PEN > "(" expressionNoEmpty() ")"}void funcPOINT() #funcPOINT :{}{  < POINT >  (    "(" expressionNoEmpty()    (      "," expressionNoEmpty()    )?    ")"  )}void funcPOS() #funcPOS :{}{  < POS > "(" expressionNoEmpty() ")"}void funcRIGHT() #funcRIGHT :{}{  < RIGHT_D > "(" expressionNoEmpty() "," expressionNoEmpty() ")"}void funcRND() #funcRND :{}{  < RND >  (    "(" expressionNoEmpty() ")"  )?}void funcSEARCH() #funcSEARCH :{  Token t = null;}{  < SEARCH > "(" t = identifier() "," expressionNoEmpty() expression_2() ")"  {    jjtThis.addToken(t);  }}void funcSGN() #funcSGN :{}{  < SGN > "(" expressionNoEmpty() ")"}void funcSIN() #funcSIN :{}{  < SIN > "(" expressionNoEmpty() ")"}void funcSPACE() #funcSPACE :{}{  < SPACE_D > "(" expressionNoEmpty() ")"}void funcSQR() #funcSQR :{}{  < SQR > "(" expressionNoEmpty() ")"}void funcSTR() #funcSTR :{}{  < STR_D > "(" expressionNoEmpty() ")"}void funcSTRING() #funcSTRING :{}{  < STRING_D > "(" expressionNoEmpty() "," expressionNoEmpty() ")"}void funcTAN() #funcTAN :{}{  < TAN > "(" expressionNoEmpty() ")"}void funcTIME() #funcTIME :{}{  < TIME_D >}void funcVAL() #funcVAL :{}{  < VAL > "(" expressionNoEmpty() ")"}/** Primary expression. */void primaryExpression() :{}{  literal()| id()| "(" expression() ")"}void id() #id :{}{  variable()}/** A literal. */void literal() :{}{  LOOKAHEAD(2)  intConst()| LOOKAHEAD(2)  doubleConst()| singleConst()| stringConst()}Token intConst() #intConst :{  Token t;}{  (    t = < INTEGER > ("%")?  | t = < INTEGER16 >  | t = < INTEGER8 >  | t = < INTEGER8O >  | t = < DOUBLE > "%"  | t = < SINGLE > "%"  )  {    jjtThis.addToken(t);    return t;  }}Token singleConst() #singleConst :{  Token t;}{  (    t = < SINGLE > ("!")?  | t = < SINGLE_EXP >  | t = < DOUBLE > "!"  | t = < INTEGER > "!"  )  {    jjtThis.addToken(t);    return t;  }}Token doubleConst() #doubleConst :{  Token t;}{  (    t = < DOUBLE > ("#")?  | t = < SINGLE > "#"  | t = < INTEGER > "#"  | t = < DOUBLE_EXP >  )  {    jjtThis.addToken(t);    return t;  }}Token stringConst() #stringConst :{  Token t;}{  t = < STRING >  {    jjtThis.addToken(t);    return t;  }}Token empty() #empty :{}{  {}  {    return null;  }}
